#!/bin/bash -e

function showHelp() {
cat << EOF
Usage:
  build [options] <python version(s)> <tasks(s)>

Options:
  -h, --help       display this help information
  -v, --verbose    print output to console during container execution
      --no-cache   runs docker build without using the cache

Default:
  run unit and type tests for 3.8-3.11 as well as lint and docs

Python Versions:
  3.8, 3.9, 3.10 and 3.11 are supported for unit, func and type tasks

Tasks:
  unit    run unit tests
  func    run functional tests
  type    run typecheck
  lint    run static code analysis
  docs    generate documentation
  deps    generate list of shipped dependencies

Note:
  lint, docs, and deps are always performed on python 3.11
EOF
exit $1
}

options=$(getopt -l "help,verbose,no-cache" -o "hv" -n "build" -- "$@")
eval set -- "$options"
while true; do
    case "$1" in
        -h|--help)     showHelp;;
        -v|--verbose)  export verbose=1;;
        --no-cache)    export no_cache="--no-cache";;
        --)            shift; break;;
    esac
    shift
done

if [[ -f .settings ]]; then
    if [[ $(cat .settings | grep save-build-images) ]]; then
        export save_build_images="true"
    fi
fi

# declare lookup maps
declare -A supported_pvers=([3.8]=1 [3.9]=1 [3.10]=1 [3.11]=1)
declare -A supported_tasks=([unit]=1 [func]=1 [type]=1)
declare -A supported_other=([lint]=1 [docs]=1 [deps]=1)

# generate python and task lists
declare -a pvers; declare -a tasks;
count=0; c_pvers=0; c_tasks=0; c_other=0;

# validate args
for arg do
    if [[ $arg == -* ]]; then continue; fi
    if [[ ${supported_pvers["$arg"]} ]]; then pvers+=($arg); ((++c_pvers)); fi
    if [[ ${supported_tasks["$arg"]} ]]; then tasks+=($arg); ((++c_tasks)); fi
    if [[ ${supported_other["$arg"]} ]]; then tasks+=($arg); ((++c_other)); fi
    ((++count))
done

# show help if arg count mismatch
if [[ $((c_pvers + c_tasks + c_other)) != $count ]]; then showHelp 1; fi

# set defaults if not specified
if [[ $count == 0 || ($c_pvers == 0 && $c_tasks != 0) ]]; then pvers=("3.8" "3.9" "3.10" "3.11"); fi
if [[ $count == 0 || ($c_tasks == 0 && $c_pvers != 0) ]]; then tasks+=("unit" "type"); fi
if [[ $count == 0 ]]; then tasks+=("lint" "docs"); fi

# generate "task-pver" jobs
declare -A jobs;
for task in "${tasks[@]}"; do
    case "$task" in
        lint|docs|deps) jobs["$task-3.11"]=1;;
        *) for pver in "${pvers[@]}"; do jobs["$task-$pver"]=1; done;;
    esac
done

function copy_from_image() {
    tag=$1
    src=$2
    dest=$3

    mkdir -p $(dirname $dest)

    id=$(docker ps --all --filter name=$tag --quiet)
    if [[ $id ]]; then
        docker rm --force $id &> /dev/null
    fi

    if [[ $verbose ]]; then echo -n "Copying $src from $tag to $dest..."; fi
    docker run --detach --name $tag $tag tail -f /dev/null &> /dev/null && docker cp --quiet $tag:$src $dest
    if [[ $verbose ]]; then
        if [[ $? ]]; then echo "SUCCEEDED"; else echo "FAILED"; fi
    fi
    docker rm --force $tag &> /dev/null
}

function docker_build() {
    temp=$(mktemp)
    trap "rm $temp" EXIT
    IFS=- read -r task pver <<< $1
    tag="daml-$task-$pver"

    if [[ $CI_PIPELINE_ID ]]; then
        tag="${tag}-${CI_PIPELINE_ID}"
    fi

    if [[ $verbose ]]; then
        (docker build --pull $no_cache --progress plain --build-arg python_version=$pver --tag $tag --target $task . | tee $temp; exit ${PIPESTATUS[0]}) || result="FAILED"
    else
        docker build --pull $no_cache --build-arg python_version=$pver --tag $tag --target $task . &> $temp || result="FAILED"
    fi

    if [[ $result == "FAILED" ]]; then
        log_file="output/logs/daml-${task}-${pver}_failure_$(date +%s).log"
        echo "FAILED (see log file ${log_file})"
        mkdir -p output/logs
        cat $temp > $log_file
        if [[ ! $verbose ]]; then cat $temp; fi
        exit 1
    else
        echo SUCCEEDED
    fi

    case "$task" in
        unit|func)
            copy_from_image $tag /daml/junit.xml ./output/junit.${task}.${pver}.xml
            copy_from_image $tag /daml/.coverage ./output/.coverage.${task}.${pver}
            copy_from_image $tag /daml/htmlcov   ./output/htmlcov.${task}.${pver};;
        docs)
            copy_from_image $tag /daml/docs/_build ./docs;;
        deps)
            copy_from_image $tag /daml/requirements.txt ./output/requirements.txt;;
    esac

    if [[ -z ${save_build_images} ]]; then
        docker rmi $tag &> /dev/null
    fi
}

export -f copy_from_image
export -f docker_build

# execute jobs
case ${#jobs[@]} in
    0)  showHelp 1;;
    1)  export verbose=1; docker_build ${!jobs[@]};;
    *)  LANG=C parallel --lb --tag docker_build ::: ${!jobs[@]};;
esac
