#!/bin/bash -e

function showHelp() {
cat << EOF
Usage:
  build [options] <tasks(s)> <python version(s)>

Options:
  -b, --build-only  only build dependency images
  -h, --help        display this help information
  -v, --verbose     print output to console during container execution
      --gpu         enable gpu support on task execution
      --no-cache    runs docker build without using the cache
      --push        push all built images to repository

Default:
  run unit and type tests for 3.8-3.11 as well as lint and docs

Python Versions:
  3.8, 3.9, 3.10 and 3.11 are supported for unit, func and type tasks

Tasks:
  unit    run unit tests
  func    run functional tests
  type    run typecheck
  lint    run static code analysis
  docs    generate documentation
  qdocs   generate documentation using cached notebooks

Note:
  lint and docs are always performed on python 3.11
EOF
exit $1
}

options=$(getopt -l "help,verbose,gpu,no-cache,build-only,push" -o "hvb" -n "build" -- "$@")
eval set -- "$options"
while true; do
    case "$1" in
        -h|--help)       showHelp;;
        -v|--verbose)    export verbose=1;;
        --gpu)           export gpuflag="--gpus all";;
        --no-cache)      cache_arg="--no-cache";;
        -b|--build-only) build_only=1;;
        --push)          export push_to_repo=1;;
        --)              shift; break;;
    esac
    shift
done

if [[ -f .settings ]]; then
    if [[ $(cat .settings | grep save-build-images) ]]; then
        export save_build_images="true"
    fi
fi

# declare lookup maps
declare -A supported_pvers=([3.8]=1 [3.9]=1 [3.10]=1 [3.11]=1)
declare -A supported_tasks=([unit]=1 [func]=1 [type]=1)
declare -A supported_other=([lint]=1 [docs]=1 [qdocs]=1)

# generate python and task lists
declare -A pvers; declare -A tasks;
count=0; c_pvers=0; c_tasks=0; c_other=0;

# validate args
for arg do
    if [[ $arg == -* ]]; then continue; fi
    if [[ ${supported_pvers["$arg"]} ]]; then pvers[$arg]=1; ((++c_pvers)); fi
    if [[ ${supported_tasks["$arg"]} ]]; then tasks[$arg]=1; ((++c_tasks)); fi
    if [[ ${supported_other["$arg"]} ]]; then tasks[$arg]=1; ((++c_other)); fi
    ((++count))
done

# show help if arg count mismatch
if [[ $((c_pvers + c_tasks + c_other)) != $count ]]; then showHelp 1; fi

# set defaults if not specified
if [[ ! $build_only ]]; then
    if [[ $count == 0 || ($c_pvers == 0 && $c_tasks != 0) ]]; then pvers=([3.8]=1 [3.9]=1 [3.10]=1 [3.11]=1); fi
    if [[ $count == 0 || ($c_tasks == 0 && $c_pvers != 0) ]]; then tasks[unit]=1; tasks[type]=1; fi
    if [[ $count == 0 ]]; then tasks[lint]=1; fi
fi

# generate "task-pver" jobs
declare -A jobs;
for task in "${!tasks[@]}"; do
    case "$task" in
        lint|docs|qdocs) jobs["$task-3.11"]=1;;
        *) for pver in "${!pvers[@]}"; do jobs["$task-$pver"]=1; done;;
    esac
done
if [[ ${tasks[lint]} || ${tasks[docs]} || ${tasks[qdocs]} ]]; then pvers[3.11]=1; fi

function post_build_cleanup() {
    temp=$1
    tag=$2

    rm -f $temp

    if [[ $(docker container ls --all --filter name=$tag) ]]; then
        docker container rm --force $tag &> /dev/null
    fi

    if [[ -z $save_build_images && $(docker image ls --filter reference=$tag) ]]; then
        docker image rm --force $tag &> /dev/null
    fi
}

function build_image() {
    tag=$1
    target=$2
    python_version=$3
    cache_from_tag=$4

    if [[ $(docker manifest inspect $cache_from_tag) ]]; then
        # Optimizations are only enabled if there's a cached image to use
        python_optimization_args="\
            --build-arg pyenv_enable_opt=--enable-optimizations \
            --build-arg pyenv_with_lto=--with-lto"

        # Set the various image vars if there's a cached image available
        image_args="\
            --build-arg base_image=$deps_image:base-$python_version \
            --build-arg deps_image=$deps_image:$deps_hash-$python_version \
            --build-arg build_image=$build_image:$deps_hash-$python_version"

        docker pull $cache_from_tag
        cache_from_arg="--cache-from $cache_from_tag"
    fi

    docker_build_cmd="docker build $verbosity \
        --build-arg python_version=$python_version \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        $python_optimization_args \
        $image_args \
        $cache_from_arg \
        --tag $tag \
        --target $target \
        ."

    if [[ $verbose ]]; then
        echo "Building $tag..."
        echo $docker_build_cmd
        $docker_build_cmd
    else
        $docker_build_cmd &> /dev/null
    fi
}

function docker_run() {
    temp=$(mktemp)
    IFS=- read -r task pver <<< $1
    tag="daml-$task-$pver"

    if [[ $CI_PIPELINE_ID ]]; then
        tag="${tag}-${CI_PIPELINE_ID}"
    fi

    trap "post_build_cleanup $temp $tag" EXIT

    build_image $tag run $pver "$build_image:$deps_hash-$pver"
    docker_run_args="--name $tag $gpuflag $tag"

    if [[ $verbose ]]; then
        (echo "Running $tag..."; echo docker run $docker_run_args $task; docker run $docker_run_args $task | tee -a $temp; exit ${PIPESTATUS[0]}) || result="FAILED"
    else
        docker run $docker_run_args $task &> $temp || result="FAILED"
    fi

    if [[ $result == "FAILED" ]]; then
        log_file="output/logs/daml-${task}-${pver}_failure_$(date +%s).log"
        echo "FAILED (see log file ${log_file})"
        mkdir -p output/logs
        cat $temp > $log_file
        if [[ ! $verbose ]]; then cat $temp; fi
        exitcode=1
    else
        if [[ ! $verbose ]]; then echo SUCCEEDED; fi
        case "$task" in
            unit|func|docs) docker cp $tag:/daml/output ./;;
        esac
    fi

    exit $exitcode
}

function ensure_image() {
    target=$1
    image_name=$2
    base_or_hash=$3
    python_version=$4
    tag="$image_name:$base_or_hash-$python_version"
    main_tag="$image_name:main-$python_version"

    echo "Checking $tag image..."
    if ! $(docker manifest inspect $tag > /dev/null 2>&1); then
        build_image $tag $target $python_version $tag
        echo "Finished building $tag."
        if [[ $push_to_repo ]]; then
            echo "Pushing $tag..."
            docker push $tag
        fi
    fi

    # Base tag images do not have a main tag equivalent so we can skip main tag update
    if [[ $CI && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $push_to_repo && $base_or_hash != base ]]; then
        local main_manifest=$(docker manifest inspect $main_tag 2> /dev/null) || true
        local hash_manifest=$(docker manifest inspect $tag 2> /dev/null) || true
        if [[ "$main_manifest" != "$hash_manifest" ]]; then
            echo "Updating $main_tag image with $base_or_hash build..."
            docker pull $tag
            docker image tag $tag $main_tag
            docker push $main_tag
        else
            echo "$main_tag is up to date with $tag."
        fi
    fi
}

export DOCKER_BUILDKIT=1
export -f post_build_cleanup
export -f build_image
export -f docker_run

export deps_image="harbor.jatic.net:443/daml/daml-deps"
export build_image="harbor.jatic.net:443/daml/daml-build"

export deps_hash=$(sha256sum poetry.lock | cut -c 1-8)

if [[ -z $verbose ]]; then
    verbosity="--quiet"
else
    verbosity="--progress=plain"
fi
export verbosity

if [[ $build_only ]]; then
    (
        trap "exit 1" SIGINT
        if [[ ${#pvers[@]} == 0 ]]; then pvers=([3.8]=1 [3.9]=1 [3.10]=1 [3.11]=1); fi

        for pver in ${!pvers[@]}; do
            (
                ensure_image pybase $deps_image base $pver &&
                ensure_image pydeps $deps_image $deps_hash $pver &&
                if [[ $CI ]]; then
                    ensure_image build $build_image $deps_hash $pver
                fi
            ) || exit 1 &
        done
        wait
    )
    exit $?
fi

# execute jobs
echo "Running ${!jobs[@]}..."
case ${#jobs[@]} in
    0)  showHelp 1;;
    1)  export verbose=1; docker_run ${!jobs[@]};;
    *)  LANG=C parallel --lb --tag docker_run ::: ${!jobs[@]};;
esac
